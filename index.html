<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="reveal.js/dist/reset.css">
    <link rel="stylesheet" href="reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="reveal.js/dist/theme/black.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css" id="highlight-theme">
    <style>
        .reveal section pre code {
            font-size: 0.7em !important;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>Why I went out of my comfort zone
                <aside class="notes">
                    I had been coding for some 23 years or so, only 17 of those I actually got paid to write code.
                    I started getting paid when I worked at a PC helpdesk, this was during the home PC era 1998 or so.
                    Me and a colluge got really fed up with the totally crappy software we hade to use so we made Züper
                    App. Saved us tones of time each day, but the code was not so super. It did work however,
                    We managed to talk around the house and could have all the serialnumbers of all computers delivered,
                    before they where delivered and not 3 days later. Since people tend to call on the same day, that
                    was a huge time saver, now we could search by name instead having to manually type in all
                    information in our support system.
                    With the press of a button it would login to Posten (port-nord) and fill in all the forms to pick up
                    a PC as someones house. And so on. Really super for us. But very small system and not official in
                    any way.
                    Did not stay there for to long since the PC sales where going down and I was (am) a bit of a schmuck
                    I had a fall out with the boss and resigned in a meeting without any idea of what to do next.
                </aside>
            </section>
            <section><img src="Images/wapnet.png" />
                <aside class="notes">
                    <p>I had a friend who had started a company just a year before, so I called him up and begged him to
                        take me on board or if he begged me.<br>
                        So know we had a 2 man shop, we where supposed to do to WAP applications, this was at the time
                        when mobile phones could not deal with html.<br>
                        WAP was super hot so the company was called WAPNET.
                    </p>
                    <p>
                        However we needed money so we ended up doing a booking system for Julgalan.
                        They had been using Excel to keep track of all tickets, all food, invoices and extras and then
                        make seeting arrengements.
                        After the first year it was quite obvous it would not work, but Micke being somewhat of a sheep
                        dude didn’t want to pay big money so we did it for what we thought was a huge amount of money,
                        it wasn’t..
                    </p>
                    That system was not super great either, code wise.
                    Written in Delphi with a SQL server, It did work however and the users where happy.
                    We handled maybe 50-100 000 people each year in the system. With invoicing integrations and all.
                </aside>
            </section>
            <section>
                <img src="Images/2book.png" />
                <aside class="notes">
                    One thing lead to another and soon we had a booking system for restaurants and 12 years later we had
                    over 300 restaurants in Sweden and Norway using our system.
                    By this time I of course knew every pattern in the GOF book, oop, Union architecture and what not.
                    I had no problem making our software do what we wanted.
                    After 12 years together I left the company, the company was sold of to our biggest competitor and
                    became their premium product.
                </aside>
            </section>
            <section>
                <img src="Images/wordcloud.png">
                <aside class="notes">
                    I then worked at DGC, Movestic and Qliro. <br>
                    The whole time writing the normal C# enterprice web api stuffy that you all write every day. But it
                    was itching.. <br>
                    We did manage to get stuff out, stuff worked. But stuff took a long time and was very often overly
                    complicated. <br>
                    Or so I felt. <br>
                    When I did follow “they way to do things” ™, it was 8 interfaces and 9 classes just to check if two
                    headers values matched the values in a SQL database. <br>
                    You know we have to follow SOLID, make sure we can unit test every thing. And follow all the rules
                    to make your system maintainable.<br>
                </aside>
            </section>
            <section><img src="Images/dependency.png" />
                <aside class="notes">
                    Before you know it you have applications that look like this. <br>
                    And the only way to not end up here is to always think about everything in the last picture and even
                    more. <br>
                    But don't follow everything all the time, only when it is appropriate otherwise you end up here as
                    well. <br>
                </aside>
            </section>
            <section>
                <h1>But why?</h1>
                <aside class="notes">
                    <p>
                    Why does this happen all the Time? <br>
                    What is it that we are really doing? Are we really using the right tools for the job? <br>
                </p>
                <p>
                    On one hand yes. I mean we can absolutely build to kind of software we do today with C#<br>
                    But are there any alternatives? <br>
                </p>
                </aside>
            </section>
            <section>
                <ul>
                <li class="fragment">Machine code?</li>
                <li class="fragment">Assembler</li>
                <li class="fragment">Procedural</li>
                <li class="fragment">Functional</li>
                <li class="fragment">Allan Kay OO</li>
                <li class="fragment">C derivate OO</li>
                <li class="fragment">Functional message passing</li>
                </ul>
                <aside class="notes">
                    <p>
                    I only have some 30 minutes for this talk so I won't do any kind of deep dive in to all kinds now. <br>
                    But I think we all agree that machine code and Assembler is not the most efficient way to deliver value for us.<br>
                    I would also argue that even if we say that we doo OOP. We don't really do that. Because it is not a good fit. for us. <br>
                    </p>
                    <p>
                        Yes, we use classes and objects. But how much of our code is services, handlers, controllers and all other strange kind of things. <br>
                        And since we usually want to load balance and because threading is hard, we really on our databases to be the one place where the actual truth is.<br>
                        Backend code, mostly just take som request and transfers it either to and from a database, or to another system. <br>
                        The truth is not in our systems. <br>                        
                    </p>
                </aside>
            </section>
            <section>
                <ul style="font-size: 0.4em !important;line-height: normal !important;">
                    <li class="fragment">HTTP request parsed and routed to controller method with input variable</li>
                    <li class="fragment">Validate input with validator service</li>
                    <li class="fragment">Authenticate input with authentication service</li>
                    <li class="fragment">Convert input to Internal/Domain object</li>
                    <li class="fragment">Call invoiceService with internal object</li>
                    <li class="fragment">Invoice service calls Invoice Repository</li>
                    <li class="fragment">Invoice repository prepares SQL statement of some kind, most likeley some ORM</li>
                    <li class="fragment">Execute the SQL statement on a SQL server and wait for response</li>
                    <li class="fragment">Convert the SQL response from a db object to Internal/Domain object and return to invoice service</li>
                    <li class="fragment">Invoice service responds to controller</li>
                    <li class="fragment">Controller converts to DTO object</li>
                    <li class="fragment">Magic hooked upp things converts dto object to JSON and returns the response to the caller</li>
                <aside class="notes">
                 <p>
                     Is any of this OO?<br>
                     This could just be called Anemic models or with some fantasy it could be Active Records, and with alot of fantasy it could be called Domain driven design<br>
                     It is very hard from all points in this program to get an idea of what will happen. <br>
                     Authentication is probably not done this way, instead in some filter thingy function you have to know about. <br>
                     The mapping is done with Automapper so you don't have to mess upp all the time. But that is hidden away somewhere else<br>
                     Then we must think if DRY, so all validators and authenticators and services and what not are all quite big classes. <br>
                     That deal with input from many places, reuse you know. <br>
                     But what happened to Single Responsibility then? <br>
                 </p>
                 <p>
                     This is just procedural but with objects and classes as a way to hide functionality and maybe some state, but mostly to group different functionality together. <br>
                     Invoice 56 could be fetched by many clients at the same time, and all request would be dealt with this way. <br>
                     So it is definitely not Allay kay kind off OO, small talk etc. <br>
                     I would say it is not C style of OO either. 
                 </p>
                </aside>
            </section>
            <section>
                <ul style="font-size: 0.4em !important;line-height: normal !important;">
                    <li class="fragment">Route incoming call</li>
                    <li class="fragment">Validate input </li>
                    <li class="fragment">Authenticate input</li>
                    <li class="fragment">prepare SQL statement of some kind</li>
                    <li class="fragment">Execute the SQL statement on a SQL server and wait for response</li>
                    <li class="fragment">Parse response from a db object</li>
                    <li class="fragment">Convert the db response to a http response</li>
                <aside class="notes">
                 <p>
                     This is what we are actually doing<br>
                     What if we could write code that looked like this?
                 </p>
                </aside>
            </section>
            <section>
                <pre><code data-trim data-noescape class="lang-fsharp hljs">
                    HTTPRequest
                    |> ParseInput    
                    |> ValidateAccess
                    |> GetInvoiceFromDB
                    |> SerializeResponse
                    |> HTTPResponse
                    </code></pre>
                    <aside class="notes">
                        This is the same but written in a functional style. <br>
                        We would then only need to implement thoose functions and we would be done. <br>
                        This is composition, where we take input do something and return some output. 
                    </aside>
            </section>

            <section><img src="Images/ballonhill.png" />
                <aside class="notes">
                    This is how it felt to me. Always trying to balance the ball on the hill.<br>
                    Nothing in our tools help us stay here. Imperative languages like C# is really good. <br>
                    You can write pretty much anything you want and connect it endless ways. But this is also a
                    curse<br>
                </aside>
            </section>
            <!-- <section><img src="Images/ballinvalley.png" />
                <aside class="notes">
                    Wouldn't this be nice? <br>
                    If the way you write code tends to gravitate towards the prefered position. <br>
                    Yeah given that the position you want is in the bottom of the pit. <br>
                    This is what Mark Seman promised in his talk, Pit of success. <br>
                    He was talking about functional programing, and he is not one of these professor dudes you might
                    think of when talking about things like Haskell. <br>
                    He wrote a 500 page book about dependency injection and is a Consultant full time. <br>
                </aside>
            </section> -->
            
            <section>
                <ul>
                    <li class="fragment">input to output</li>
                    <li class="fragment">a -> b</li>
                </ul>
                <aside class="notes">
                    This is what we did. <br>
                    We took some input and did something and returned something else. <br>
                    Not a very tricky concept. I mean that is how must methods work in c#?!<br>
                    This could be written like a to b, and since we want to use symbols, we use an arrow instead of the to word. <br>
                    But what happens if the input parsing fails? Maybe it it was inccoret input? <br>
                    Yes we could throw an exception, but this is a kind of expected error! So it is important that we model it correctly. <br>
                    Maybe the output of each function could either be succes or error? <br>
                    Then we could expand on our notation. <br>
                </aside>
            </section>
            <section>
                <pre><code data-trim data-noescape class="lang-fsharp hljs">
                    HTTPRequest
                    |> ParseInput    
                    |> onSuccess ValidateAccess
                    |> onSuccess GetInvoiceFromDB
                    |> switch 
                        | onSuccess -> SerializeResponse
                        | onError -> MakeAnErrorResponse
                    |> HTTPResponse
                    </code></pre>
                    <aside class="notes">
                        If this is what we wrote in our controller, we could even show it to the PO and make sure we all share the understanding of what would happen.<br>
                        But how do we achieve this? <br>
                    </aside>
            </section>
            <section>
                <pre><code data-trim data-noescape class="lang-csharp hljs">
                    public class baseSucessError<t> {}
                    public class Sucess : baseError 
                        </code></pre>
                <pre><code data-trim data-noescape class="lang-fsharp hljs">
                type Result = 
                    | Success of T
                    | Error of E
                    </code></pre>
                <ul>
                    <li class="fragment">input -> Result&lt;InvoiceRequest,InvoiceError&gt;</li>
                </ul>
                        
                    <aside class="notes">
                        You could of course do this with inheritance. Have a base class and then make subclasses that are either success or error. <br>
                        But that would mean tons of code.. I'm lazy I don't like to write code.. <br>
                        And nothing would stop our inhertance to break apart big time if the actaul subclasses did inherit directly from the baseclass instead of Error or Sucess. <br>

                    </aside>
            </section>
           

            <section>
                HTTP request -> HTTP Response
                <aside class="notes">
                 <p>
                 When building an API this is what you are doing. <br>
                 You take a HTTP request and then you fiddle around a bit and then you return a HTTP Response. 
                 </p>
                 <p>
                 Does this 
 
             </p>
                </aside>
            </section>
            <section>
                <pre><code data-trim data-noescape class="lang-fsharp hljs">
                        printf "Hello world"
                    </code></pre>
                <aside class="notes">
                    See, not very hard. <br>
                    Just as promossed the amount of code whent down by alot. Just type this in a file, and compile it.
                    It will print print "Hello world"<br>
                    The same in C# actually is much more code, you would need to have a class and a entry point and what
                    not. <br>
                    Yes, if you want the f# thingy to compile to an exe you actually have to write a bit more. <br>
                </aside>
            </section>
            <section>
                <pre><code data-trim data-noescape class="lang-fsharp hljs">
                        [&lt;EntryPoint&gt;]
                            let main argv =
                                printfn "Hello World"
                                0 // return an integer exit code
                    </code></pre>
                <aside class="notes">
                    Not very hard this functional thingy..<br>
                    And indeed a bit shorter then the c# code. <br>
                    Not that the C# thing is particualalry hard either
                </aside>
            </section>
            <section>
            <pre><code data-trim data-noescape class="lang-Csharp hljs">
                    using System;

                    namespace ConsoleApp1
                    {
                        class Program
                        {
                            static void Main(string[] args)
                            {
                                Console.WriteLine("Hello World!");
                            }
                        }
                    }
                </code></pre>
            <aside class="notes">
                And it is just boilerplate things that Visual studio will write out anyhow so why care?<br>
                And What the heck is the difference? <br>
                I mean, sure some less code but the actual typing is the same.<br>
                So it just another syntax, maybe fine. But why on earth would I spend time to learn that? <br>
                <br>
                It is not just new syntax. <br>
                But how this solve everything? 
            </aside>
           </section>
          
           

           <section>
                <pre><code data-trim data-noescape class="lang-fsharp hljs">
                    let authRoutes principalStore (resolver: Resolver): HttpHandler list = [
                        POST >=> route "/v1/auth/start" >=> resolver.toWebPart Auth.Views.start
                        POST >=> route "/v1/auth/status" >=> resolver.toWebPart Auth.Views.status
                        POST >=> route "/v1/auth/verify" >=> resolver.toWebPart (Auth.Views.verify principalStore)
                        POST >=> route "/v1/auth/cancel" >=> resolver.toWebPart Auth.Views.cancel
                        POST >=> route "/v1/auth/refresh" >=> resolver.toWebPart Auth.Views.refresh
                    ]
					</code></pre>
            </section>
            <section>
                <pre><code data-trim data-noescape class="lang-csharp hljs" style="font-size: 0.4em !important;line-height: normal !important;">
                        public class AuthController : Controller
                        {
                            [Route("Auth/start")]
                            public IActionResult Start()
                            {
                                return View();
                            }
                    
                            [Route("Auth/Status")]
                            public IActionResult Status()
                            {
                                return View();
                            }
                    
                            [Route("Auth/Verify")]
                            public IActionResult Verify()
                            {
                                return View();
                            }
                            
                            [Route("Auth/Cancel")]
                            public IActionResult Cancel()
                            {
                                return View();
                            }
                    
                            [Route("Auth/Cancel")]
                            public IActionResult Refresh()
                            {
                                return View();
                            }
                    
                        }
					</code></pre>
            </section>
        </div>

    </div>

    <script src="reveal.js/dist/reveal.js"></script>
    <script src="reveal.js/plugin/notes/notes.js"></script>
    <script src="reveal.js/plugin/markdown/markdown.js"></script>
    <script src="reveal.js/plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>